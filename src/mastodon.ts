import { OAuth2 } from 'oauth'
import APIClient from './api_client'
import { ProxyConfig } from './proxy_config'
import OAuth from './oauth'
import Response from './response'

const NO_REDIRECT = 'urn:ietf:wg:oauth:2.0:oob'
const DEFAULT_URL = 'https://mastodon.social'
const DEFAULT_SCOPE = 'read write follow'
const DEFAULT_UA = 'megalodon'

export interface MastodonInterface {}

export default class Mastodon implements MastodonInterface {
  public client: APIClient

  constructor(
    accessToken: string,
    baseUrl: string = DEFAULT_URL,
    userAgent: string = DEFAULT_UA,
    proxyConfig: ProxyConfig | false = false
  ) {
    this.client = new APIClient(accessToken, baseUrl, userAgent, proxyConfig)
  }

  /**
   * First, call createApp to get client_id and client_secret.
   * Next, call generateAuthUrl to get authorization url.
   * @param clientName Form Data, which is sent to /api/v1/apps
   * @param options Form Data, which is sent to /api/v1/apps. and properties should be **snake_case**
   * @param baseUrl base URL of the target
   * @param proxyConfig Proxy setting, or set false if don't use proxy.
   */
  public static async registerApp(
    clientName: string,
    options: Partial<{ scopes: string; redirect_uris: string; website: string }> = {
      scopes: DEFAULT_SCOPE,
      redirect_uris: NO_REDIRECT
    },
    baseUrl = DEFAULT_URL,
    proxyConfig: ProxyConfig | false = false
  ): Promise<OAuth.AppData> {
    return this.createApp(clientName, options, baseUrl, proxyConfig).then(async appData => {
      return this.generateAuthUrl(
        appData.client_id,
        appData.client_secret,
        {
          redirect_uri: appData.redirect_uri,
          scope: options.scopes
        },
        baseUrl
      ).then(url => {
        appData.url = url
        return appData
      })
    })
  }

  /**
   * Create an application
   *
   * First, POST /api/v1/apps.
   * @param client_name your application's name
   * @param options Form Data
   * @param baseUrl target of base URL
   * @param proxyConfig Proxy setting, or set false if don't use proxy.
   */
  public static async createApp(
    client_name: string,
    options: Partial<{ redirect_uris: string; scopes: string; website: string }> = {
      redirect_uris: NO_REDIRECT,
      scopes: DEFAULT_SCOPE
    },
    baseUrl = DEFAULT_URL,
    proxyConfig: ProxyConfig | false = false
  ): Promise<OAuth.AppData> {
    const redirect_uris = options.redirect_uris || NO_REDIRECT
    const scopes = options.scopes || DEFAULT_SCOPE

    const params: {
      client_name: string
      redirect_uris: string
      scopes: string
      website?: string
    } = {
      client_name,
      redirect_uris,
      scopes
    }
    if (options.website) params.website = options.website

    return APIClient.post<OAuth.AppDataFromServer>(
      '/api/v1/apps',
      params,
      baseUrl,
      proxyConfig
    ).then((res: Response<OAuth.AppDataFromServer>) => OAuth.AppData.from(res.data))
  }

  /**
   * Generate authorization url using OAuth2.
   *
   * @param clientId your OAuth app's client ID
   * @param clientSecret your OAuth app's client Secret
   * @param options as property, redirect_uri and scope are available, and must be the same as when you register your app
   * @param baseUrl base URL of the target
   */
  public static generateAuthUrl(
    clientId: string,
    clientSecret: string,
    options: Partial<{ redirect_uri: string; scope: string }> = {
      redirect_uri: NO_REDIRECT,
      scope: DEFAULT_SCOPE
    },
    baseUrl = DEFAULT_URL
  ): Promise<string> {
    return new Promise(resolve => {
      const oauth = new OAuth2(clientId, clientSecret, baseUrl, undefined, '/oauth/token')
      const url = oauth.getAuthorizeUrl({
        redirect_uri: options.redirect_uri,
        response_type: 'code',
        client_id: clientId,
        scope: options.scope
      })
      resolve(url)
    })
  }

  /**
   * Fetch OAuth access token.
   * Get an access token based client_id and client_secret and authorization code.
   *
   * @param client_id will be generated by #createApp or #registerApp
   * @param client_secret will be generated by #createApp or #registerApp
   * @param code will be generated by the link of #generateAuthUrl or #registerApp
   * @param baseUrl base URL of the target
   * @param redirect_uri must be the same uri as the time when you register your OAuth application
   * @param proxyConfig Proxy setting, or set false if don't use proxy.
   */
  public static async fetchAccessToken(
    client_id: string,
    client_secret: string,
    code: string,
    baseUrl = DEFAULT_URL,
    redirect_uri = NO_REDIRECT,
    proxyConfig: ProxyConfig | false = false
  ): Promise<OAuth.TokenData> {
    return APIClient.post<OAuth.TokenDataFromServer>(
      '/oauth/token',
      {
        client_id,
        client_secret,
        code,
        redirect_uri,
        grant_type: 'authorization_code'
      },
      baseUrl,
      proxyConfig
    ).then((res: Response<OAuth.TokenDataFromServer>) => OAuth.TokenData.from(res.data))
  }

  /**
   * Refresh OAuth access token.
   * Send refresh token and get new access token.
   *
   * @param client_id will be generated by #createApp or #registerApp
   * @param client_secret will be generated by #createApp or #registerApp
   * @param refresh_token will be get #fetchAccessToken
   * @param baseUrl base URL or the target
   * @param proxyConfig Proxy setting, or set false if don't use proxy.
   */
  public static async refreshToken(
    client_id: string,
    client_secret: string,
    refresh_token: string,
    baseUrl = DEFAULT_URL,
    proxyConfig: ProxyConfig | false = false
  ): Promise<OAuth.TokenData> {
    return APIClient.post<OAuth.TokenDataFromServer>(
      '/oauth/token',
      {
        client_id,
        client_secret,
        refresh_token,
        grant_type: 'refresh_token'
      },
      baseUrl,
      proxyConfig
    ).then((res: Response<OAuth.TokenDataFromServer>) => OAuth.TokenData.from(res.data))
  }
}
